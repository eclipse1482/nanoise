"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var bip32_key_derivation_1 = __importDefault(require("./bip32-key-derivation"));
var bip39_mnemonic_1 = __importDefault(require("./bip39-mnemonic"));
var ed25519_1 = __importDefault(require("./ed25519"));
var nano_address_1 = __importDefault(require("./nano-address"));
var signer_1 = __importDefault(require("./signer"));
var convert_1 = __importDefault(require("./util/convert"));
var AddressImporter = /** @class */ (function () {
    function AddressImporter() {
    }
    var _a;
    _a = AddressImporter;
    /**
     * Import a wallet using a mnemonic phrase
     *
     * @param {string} mnemonic - The mnemonic words to import the wallet from
     * @param {string} [seedPassword] - (Optional) The password to use to secure the mnemonic
     * @returns {Wallet} - The wallet derived from the mnemonic phrase
     */
    AddressImporter.fromMnemonic = function (mnemonic, seedPassword) {
        if (seedPassword === void 0) { seedPassword = ''; }
        if (!bip39_mnemonic_1.default.validateMnemonic(mnemonic)) {
            throw new Error('Invalid mnemonic phrase');
        }
        var seed = bip39_mnemonic_1.default.mnemonicToSeed(mnemonic, seedPassword);
        var accounts = _a.accounts(seed, 0, 0);
        return {
            mnemonic: mnemonic,
            seed: seed,
            accounts: accounts,
        };
    };
    /**
     * Import a legacy wallet using a mnemonic phrase
     *
     * @param {string} mnemonic - The mnemonic words to import the wallet from
     * @returns {Wallet} - The wallet derived from the mnemonic phrase
     */
    AddressImporter.fromLegacyMnemonic = function (mnemonic) {
        if (!bip39_mnemonic_1.default.validateMnemonic(mnemonic)) {
            throw new Error('Invalid mnemonic phrase');
        }
        var seed = bip39_mnemonic_1.default.mnemonicToLegacySeed(mnemonic);
        return _a.fromLegacySeed(seed, 0, 0, mnemonic);
    };
    /**
     * Validate mnemonic words
     *
     * @param mnemonic {string} mnemonic - The mnemonic words to validate
     */
    AddressImporter.validateMnemonic = function (mnemonic) {
        return bip39_mnemonic_1.default.validateMnemonic(mnemonic);
    };
    /**
     * Import a wallet using a seed
     *
     * @param {string} seed - The seed to import the wallet from
     * @param {number} [from] - (Optional) The start index of the private keys to derive from
     * @param {number} [to] - (Optional) The end index of the private keys to derive to
     * @returns {Wallet} The wallet derived from the mnemonic phrase
     */
    AddressImporter.fromSeed = function (seed, from, to) {
        if (from === void 0) { from = 0; }
        if (to === void 0) { to = 0; }
        if (seed.length !== 128) {
            throw new Error('Invalid seed length, must be a 128 byte hexadecimal string');
        }
        if (!/^[0-9a-fA-F]+$/i.test(seed)) {
            throw new Error('Seed is not a valid hexadecimal string');
        }
        var accounts = _a.accounts(seed, from, to);
        return {
            mnemonic: undefined,
            seed: seed,
            accounts: accounts,
        };
    };
    /**
     * Import a wallet using a legacy seed
     *
     * @param {string} seed - The seed to import the wallet from
     * @param {number} [from] - (Optional) The start index of the private keys to derive from
     * @param {number} [to] - (Optional) The end index of the private keys to derive to
     * @returns {Wallet} The wallet derived from the seed
     */
    AddressImporter.fromLegacySeed = function (seed, from, to, mnemonic) {
        if (from === void 0) { from = 0; }
        if (to === void 0) { to = 0; }
        if (seed.length !== 64) {
            throw new Error('Invalid seed length, must be a 64 byte hexadecimal string');
        }
        if (!/^[0-9a-fA-F]+$/i.test(seed)) {
            throw new Error('Seed is not a valid hexadecimal string');
        }
        var accounts = _a.legacyAccounts(seed, from, to);
        return {
            mnemonic: mnemonic || bip39_mnemonic_1.default.deriveMnemonic(seed),
            seed: seed,
            accounts: accounts,
        };
    };
    /**
     * Derives BIP32 private keys
     *
     * @param {string} seed - The seed to use for private key derivation
     * @param {number} from - The start index of private keys to derive from
     * @param {number} to - The end index of private keys to derive to
     */
    AddressImporter.accounts = function (seed, from, to) {
        var accounts = [];
        for (var i = from; i <= to; i++) {
            var privateKey = bip32_key_derivation_1.default.derivePath("44'/165'/".concat(i, "'"), seed).key;
            var keyPair = new ed25519_1.default().generateKeys(privateKey);
            var address = nano_address_1.default.deriveAddress(keyPair.publicKey);
            accounts.push({
                accountIndex: i,
                privateKey: keyPair.privateKey,
                publicKey: keyPair.publicKey,
                address: address,
            });
        }
        return accounts;
    };
    /**
     * Derives legacy private keys
     *
     * @param {string} seed - The seed to use for private key derivation
     * @param {number} from - The start index of private keys to derive from
     * @param {number} to - The end index of private keys to derive to
     */
    AddressImporter.legacyAccounts = function (seed, from, to) {
        var accounts = [];
        for (var i = from; i <= to; i++) {
            var privateKey = convert_1.default.ab2hex(signer_1.default.generateHash([seed, convert_1.default.dec2hex(i, 4)]));
            var keyPair = new ed25519_1.default().generateKeys(privateKey);
            var address = nano_address_1.default.deriveAddress(keyPair.publicKey);
            accounts.push({
                accountIndex: i,
                privateKey: keyPair.privateKey,
                publicKey: keyPair.publicKey,
                address: address,
            });
        }
        return accounts;
    };
    return AddressImporter;
}());
exports.default = AddressImporter;
