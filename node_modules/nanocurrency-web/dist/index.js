"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.box = exports.tools = exports.block = exports.wallet = void 0;
var address_generator_1 = __importDefault(require("./lib/address-generator"));
var address_importer_1 = __importDefault(require("./lib/address-importer"));
var block_signer_1 = __importDefault(require("./lib/block-signer"));
var box_1 = __importDefault(require("./lib/box"));
var nano_address_1 = __importDefault(require("./lib/nano-address"));
var nano_converter_1 = __importDefault(require("./lib/nano-converter"));
var signer_1 = __importDefault(require("./lib/signer"));
var convert_1 = __importDefault(require("./lib/util/convert"));
var wallet = {
    /**
     * Generate a new Nano cryptocurrency wallet
     *
     * This function generates a wallet from random entropy. Wallet includes
     * a BIP39 mnemonic phrase in line with the Nano Ledger implementation and
     * a seed, the account is derived using BIP32 deterministic hierarchial algorithm
     * with input parameters 44'/165' and index 0.
     *
     * The Nano address is derived from the public key using standard Nano encoding.
     * The address is prefixed with 'nano_'.
     *
     * Generation uses CryptoJS to generate random entropy by default. You can give your own entropy
     * as a parameter and it will be used instead.
     *
     * An optional seed password can be used to encrypt the mnemonic phrase so the seed
     * cannot be derived correctly without the password. Recovering the wallet without the
     * password is not possible.
     *
     * @param {string} [entropy] - (Optional) 64 byte hexadecimal string entropy to be used instead of generating it
     * @param {string} [seedPassword] - (Optional) seed password
     * @returns {Wallet} The wallet
     */
    generate: function (entropy, seedPassword) {
        return address_generator_1.default.generateWallet(entropy, seedPassword);
    },
    /**
     * Generate a new Nano cryptocurrency wallet
     *
     * This function generates a legacy wallet from a random seed. Wallet includes
     * a mnemonic phrase and a seed, the account is derived from the seed at index 0.
     *
     * The Nano address is derived from the public key using standard Nano encoding.
     * The address is prefixed with 'nano_'.
     *
     * Generation uses CryptoJS to generate random seed by default. You can give your own seed
     * as a parameter and it will be used instead.
     *
     * @param {string} [seed] - (Optional) 64 byte hexadecimal string seed to be used instead of generating it
     * @returns {Wallet} The wallet
     */
    generateLegacy: function (seed) {
        return address_generator_1.default.generateLegacyWallet(seed);
    },
    /**
     * Import a Nano cryptocurrency wallet from a mnemonic phrase
     *
     * This function imports a wallet from a mnemonic phrase. Wallet includes the mnemonic phrase,
     * a seed derived with BIP39 standard and an account derived using BIP32 deterministic hierarchial
     * algorithm with input parameters 44'/165' and index 0.
     *
     * The Nano address is derived from the public key using standard Nano encoding.
     * The address is prefixed with 'nano_'.
     *
     * @param {string} mnemonic - The mnemonic phrase. Words are separated with a space
     * @param {string} [seedPassword] - (Optional) seed password
     * @throws Throws an error if the mnemonic phrase doesn't pass validations
     * @returns {Wallet} The wallet
     */
    fromMnemonic: function (mnemonic, seedPassword) {
        return address_importer_1.default.fromMnemonic(mnemonic, seedPassword);
    },
    /**
     * Import a Nano cryptocurrency wallet from a legacy mnemonic phrase
     *
     * This function imports a wallet from an old Nano mnemonic phrase. Wallet includes the mnemonic
     * phrase, a seed which represents the mnemonic and an account derived from the seed at index 0.
     *
     * The Nano address is derived from the public key using standard Nano encoding.
     * The address is prefixed with 'nano_'.
     *
     * @param {string} mnemonic - The mnemonic phrase. Words are separated with a space
     * @throws Throws an error if the mnemonic phrase doesn't pass validations
     * @returns {Wallet} The wallet
     */
    fromLegacyMnemonic: function (mnemonic) {
        return address_importer_1.default.fromLegacyMnemonic(mnemonic);
    },
    /**
     * Import a Nano cryptocurrency wallet from a seed
     *
     * This function imports a wallet from a seed. Wallet includes the seed and an account derived using
     * BIP39 standard and an account derived using BIP32 deterministic hierarchial algorithm with input
     * parameters 44'/165' and index 0.
     *
     * The Nano address is derived from the public key using standard Nano encoding.
     * The address is prefixed with 'nano_'.
     *
     * @param {string} seed - The seed
     * @returns {Wallet} The wallet, without the mnemonic phrase because it's not possible to infer backwards
     */
    fromSeed: function (seed) {
        return address_importer_1.default.fromSeed(seed);
    },
    /**
     * Import Nano cryptocurrency accounts from a legacy hex seed
     *
     * This function imports a wallet from a seed. The private key is derived from the seed using
     * simply a blake2b hash function. The public key is derived from the private key using the ed25519 curve
     * algorithm.
     *
     * The Nano address is derived from the public key using standard Nano encoding.
     * The address is prefixed with 'nano_'.
     *
     * @param {string} seed - The seed
     * @returns {Wallet} The wallet
     */
    fromLegacySeed: function (seed) {
        return address_importer_1.default.fromLegacySeed(seed);
    },
    /**
     * Derive accounts for the seed
     *
     * This function derives Nano accounts with the BIP32 deterministic hierarchial algorithm
     * from the given seed with input parameters 44'/165' and indexes based on the from and to
     * parameters.
     *
     * @param {string} seed - The seed
     * @param {number} from - The start index
     * @param {number} to - The end index
     * @returns {Account[]} a list of accounts
     */
    accounts: function (seed, from, to) {
        return address_importer_1.default.fromSeed(seed, from, to).accounts;
    },
    /**
     * Derive accounts for the legacy hex seed
     *
     * This function derives Nano accounts with the given seed with indexes
     * based on the from and to parameters.
     *
     * @param {string} seed - The seed
     * @param {number} from - The start index
     * @param {number} to - The end index
     * @returns {Account[]} a list of accounts
     */
    legacyAccounts: function (seed, from, to) {
        return address_importer_1.default.fromLegacySeed(seed, from, to).accounts;
    },
};
exports.wallet = wallet;
var block = {
    /**
     * Sign a send block with the input parameters
     *
     * For a send block, put your own address to the 'fromAddress' property and
     * the recipient address to the 'toAddress' property.
     * All the NANO amounts should be input in RAW format. The addresses should be
     * valid Nano addresses. Fetch the current balance, frontier (previous block) and
     * representative address from the network.
     *
     * The return value of this function is ready to be published to the network.
     *
     * NOTICE: Always fetch up-to-date account info from the network
     *         before signing the block.
     *
     * @param {SendBlock} data The data for the block
     * @param {string} privateKey Private key to sign the block
     * @returns {SignedBlock} the signed block
     */
    send: function (data, privateKey) {
        return block_signer_1.default.send(data, privateKey);
    },
    /**
     * Sign a receive block with the input parameters
     *
     * For a receive block, put your own address to the 'toAddress' property.
     * All the NANO amounts should be input in RAW format. The addresses should be
     * valid Nano addresses. Fetch the current balance, frontier (previous block) and
     * representative address from the network.
     * Input the receive amount and transaction hash from the pending block.
     *
     * The return value of this function is ready to be published to the network.
     *
     * NOTICE: Always fetch up-to-date account info from the network
     *         before signing the block.
     *
     * @param {ReceiveBlock} data The data for the block
     * @param {string} privateKey Private key to sign the block
     * @returns {SignedBlock} the signed block
     */
    receive: function (data, privateKey) {
        return block_signer_1.default.receive(data, privateKey);
    },
    /**
     * Sign a representative change block with the input parameters
     *
     * For a change block, put your own address to the 'address' property.
     * All the NANO amounts should be input in RAW format. The addresses should be
     * valid Nano addresses. Fetch the current balance, previous block from the
     * network. Set the new representative address
     * as the representative.
     *
     * NOTICE: Always fetch up-to-date account info from the network
     *         before signing the block.
     *
     * @param {RepresentativeBlock} data The data for the block
     * @param {string} privateKey Private key to sign the block
     * @returns {SignedBlock} the signed block
     */
    representative: function (data, privateKey) {
        var block = __assign(__assign({}, data), { fromAddress: data.address, amountRaw: '0', toAddress: 'nano_1111111111111111111111111111111111111111111111111111hifc8npp' });
        return block_signer_1.default.send(block, privateKey);
    },
};
exports.block = block;
var tools = {
    /**
     * Convert Nano values
     *
     * Possible units are RAW, NANO, MRAI, KRAI, RAI
     *
     * @param {string | BigNumber} input The input value
     * @param {string} inputUnit The unit of the input value
     * @param {string} outputUnit The unit you wish to convert to
     * @returns {string} The converted value
     */
    convert: function (input, inputUnit, outputUnit) {
        return nano_converter_1.default.convert(input, inputUnit, outputUnit);
    },
    /**
     * Sign any strings with the user's private key
     *
     * @param {string} privateKey The private key to sign with
     * @param {...string} input Data to sign
     * @returns {string} The signature
     */
    sign: function (privateKey) {
        var input = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            input[_i - 1] = arguments[_i];
        }
        var data = input.map(convert_1.default.stringToHex);
        return signer_1.default.sign.apply(signer_1.default, __spreadArray([privateKey], __read(data), false));
    },
    /**
     * Verifies the signature of any input string
     *
     * @param {string} publicKey The public key to verify with
     * @param {string} signature The signature to verify
     * @param {...string} input Data to verify
     * @returns {boolean} valid or not
     */
    verify: function (publicKey, signature) {
        var input = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            input[_i - 2] = arguments[_i];
        }
        var data = input.map(convert_1.default.stringToHex);
        return signer_1.default.verify.apply(signer_1.default, __spreadArray([publicKey, signature], __read(data), false));
    },
    /**
     * Verifies the signature of any input string
     *
     * @param {string} publicKey The public key to verify with
     * @param {BlockData} block The block to verify
     * @returns {boolean} valid or not
     */
    verifyBlock: function (publicKey, block) {
        var preamble = 0x6.toString().padStart(64, '0');
        return signer_1.default.verify(publicKey, block.signature, preamble, nano_address_1.default.nanoAddressToHexString(block.account), block.previous, nano_address_1.default.nanoAddressToHexString(block.representative), convert_1.default.dec2hex(block.balance, 16).toUpperCase(), block.link);
    },
    /**
     * Validate a Nano address
     *
     * @param {string} input The address to validate
     * @returns {boolean} valid or not
     */
    validateAddress: function (input) {
        return nano_address_1.default.validateNanoAddress(input);
    },
    /**
     * Validate mnemonic words
     *
     * @param {string} input The address to validate
     * @returns {boolean} valid or not
     */
    validateMnemonic: function (input) {
        return address_importer_1.default.validateMnemonic(input);
    },
    /**
     * Convert a Nano address to a public key
     *
     * @param {string} input Nano address to convert
     * @returns {string} the public key
     */
    addressToPublicKey: function (input) {
        return nano_address_1.default.addressToPublicKey(input);
    },
    /**
     * Convert a public key to a Nano address
     *
     * @param {string} input Public key to convert
     * @returns {string} the nano address
     */
    publicKeyToAddress: function (input) {
        return nano_address_1.default.deriveAddress(input);
    },
    /**
     * Hash a string or array of strings with blake2b
     *
     * @param {string | string[]} input string to hash
     * @returns {string} hashed string
     */
    blake2b: function (input) {
        if (Array.isArray(input)) {
            return convert_1.default.ab2hex(signer_1.default.generateHash(input.map(convert_1.default.stringToHex)));
        }
        else {
            return convert_1.default.ab2hex(signer_1.default.generateHash([convert_1.default.stringToHex(input)]));
        }
    },
};
exports.tools = tools;
var box = {
    /**
     * Encrypt a message using a Nano address private key for
     * end-to-end encrypted messaging.
     *
     * Encrypts the message using the recipient's public key,
     * the sender's private key and a random nonce generated
     * inside the library. The message can be opened with the
     * recipient's private key and the sender's public key by
     * using the decrypt method.
     *
     * @param {string} message string to encrypt
     * @param {string} address nano address of the recipient
     * @param {string} privateKey private key of the sender
     * @returns {string} encrypted message encoded in Base64
     */
    encrypt: function (message, address, privateKey) {
        return box_1.default.encrypt(message, address, privateKey);
    },
    /**
     * Decrypt a message using a Nano address private key.
     *
     * Decrypts the message by using the sender's public key,
     * the recipient's private key and the nonce which is included
     * in the encrypted message.
     *
     * @param {string} encrypted string to decrypt
     * @param {string} address nano address of the sender
     * @param {string} privateKey private key of the recipient
     * @returns {string} decrypted message encoded in UTF-8
     */
    decrypt: function (encrypted, address, privateKey) {
        return box_1.default.decrypt(encrypted, address, privateKey);
    }
};
exports.box = box;
